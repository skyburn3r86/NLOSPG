% Generated by/Last edit by
% Author:           Christian Haffner/Christian Haffner
% E-Mail:           chrisitan.haffner@ief.ee.ethz.ch
% Organization:     ETHZ ITET IEF

%% Funciton: finds the list entry that correspond to  max/min of data(dataYZ_str)
function [extracted_results, data_axis, extracted_parameters, error_prompt]= searchLISTforFOM(sim_results, para_list, varargin) 

%% input parameters:
% sim_results = Matrix (row = nr of simultion, column Y- result y)
% para_list = Matrix (row = nr of  simultionn, column Y- para y)
% VARARGIN options (extend on need)
% 1. 'data_str' - string needs to match result property string
% 2. 'data_FOM' - string of either 'max' or 'min' to search for optimal
% sol. in parameter space
% 3. 'para_str' - cell of strings needs to match results. 
        % 1st element = X-axis,  
        % 2nd element = Y-axis if length(values) > 1  
        % 3rd,4th... element = stated variables are subject to limited parametervalue defined by input argument para_values
% 4. 'para_values' (Optional) - cell of arrays containg parameters of interest. 
        % Cell length has to match cel length para_str 
% 5. 'data_minORmax'... defines if searching for max or minimal parameters

% Processing of variable inputs-------------------------------------
if round(length(varargin)/2)~=length(varargin)/2
    error('Arguments needs propertyName/propertyValue pairs')
end
error_prompt = [];
extracted_results = [];
data_axis = [];
extracted_parameters = [];


% scans through varagin for wavelength. -1 and +1 of for loop due to
% option/value pairs
for list_loop = 1:2:length(varargin)-1
    if ~iscell(varargin{list_loop})
        switch varargin{list_loop}
            case 'data_str'
                dataYZ.str = varargin{list_loop+1};
                for idx = 1:length(sim_results{1,1})
                    if (strcmp(dataYZ.str, sim_results{1}(idx).str))
                        data_colmn = idx;
                        str_data = sim_results{1}(idx).str;
                        str_unit = sim_results{1}(idx).unit;
                    end
                end
            case 'FOM_minORmax'
                data_FOM.str = varargin{list_loop+1};
            case 'para_str'
                cell_param.str = varargin{list_loop+1};
                for idx_para_str = 1:length( cell_param.str)
                    colm_in_para_list(idx_para_str) = find(strcmp(para_list.str, cell_param.str{idx_para_str}));
                    if isempty(colm_in_para_list(idx_para_str))
                        error(['Call of funciton plotResultList' cell_param.str 'does not match a para_list.str']);
                    else
                        % saves the parameter name
                        para{idx_para_str}.str = cell_param.str{idx_para_str};
                        para{idx_para_str}.unit = para_list.unit{colm_in_para_list(idx_para_str)};
                    end
                end             
%             case 'para_unit'
%                 cell_param.unit = varargin{list_loop+1};
%                 for idx_para_str = 1:length(cell_param.unit)
%                         % saves the parameter name
%                         para{idx_para_str}.unit = cell_param.unit{idx_para_str};
%                 end
            case 'para_value'
                cell_param.values = varargin{list_loop+1};
                for idx_para_str = 1:length( cell_param.str)
                    % uses default parameter value if not defined = empty
                    % cell element
                    if isempty(cell_param.values{idx_para_str})
                        para{idx_para_str}.values =  unique(para_list.values(:,colm_in_para_list(idx_para_str)),'stable');
                    else
                        para{idx_para_str}.values = cell_param.values{idx_para_str};
                    end
                end
%             case 'save'
%                 save_path = varargin{list_loop+1};
%             case 'legend_flag'
%                 legend_flag = varargin{list_loop+1};
%             case 'position'
%                 if isnumeric(varargin{list_loop+1})
%                     paper_size = varargin{list_loop+1};
%                 else
%                     error_prompt = ('position needs to be defined by an array of type [posx, posy, width, height] given in centimeters');
%                     return
%                 end
        end
    end
end
clear list_loop
%% Extracting data from list
user_parameter_vector = ones(length(para_list.values(:,1)),1);
% scans througt simulaiton parameter values comparing them with the values in the simulation parameter list. 
for idx_parameter = 1:length(para)
    colm_list = colm_in_para_list(idx_parameter);
    row_vector = 0;
    % the 2 if cases check if parameter (para) defined by user is within min and maximum of para_list
    if min(para{idx_parameter}.values) > min(para_list.values(:,colm_list))*0.9999
        if max(para{idx_parameter}.values) < max(para_list.values(:,colm_list))*1.001
            for idx_list = 1:length(para_list.values(:,colm_list))
                rel_error = abs((para{idx_parameter}.values - para_list.values(idx_list,colm_list))./para_list.values(idx_list,colm_list));
                row_vector(idx_list,1) = ~isempty(find(rel_error < 1e-3));
            end
        else
            error_prompt = (['parameter values is not within [min max]' para{idx_parameter}.str 'value range obtained from the simulation parameter list - please redefine']);
            return
        end
    else
        error_prompt = (['parameter values is not within [min max]' para{idx_parameter}.str 'value range obtained from the simulation parameter list - please redefine']);
        return
    end
    % contains the row number for the specified parameter set
    user_parameter_vector = user_parameter_vector & row_vector;
    % error handling
    if sum(row_vector) == 0        
        error_prompt = (['********************************************** \n'...
            'given value:' num2str(para{idx_parameter}.values) ' of paramter:' para{idx_parameter}.str ' does not match simulation parameter list'...
            '********************************************** \n']);
        return
    end
end

clear idx_parameter;
% Transforms cell structure of result into 1D array interest
counter = 1;
for idx_row_list = 1:length(user_parameter_vector)
    if (user_parameter_vector(idx_row_list))
        results = sim_results{idx_row_list};
        results_structure{counter} = results;
        results = results(data_colmn);
        FOM(counter,1) = results.value;
        parameter(counter,:) = para_list.values(idx_row_list,:);
        counter = counter + 1;
    end   
end

clear counter;
% reshaping data from list into matrix
 for idx_para1 = 1:length(para{1}.values)
        para_1_value = para{1}.values(idx_para1);
        for idx_para2 = 1:length(para{2}.values)
            para_2_value = para{2}.values(idx_para2);
            dummy_value = [];
            for idx_list_loop = 1:length(parameter)
                current_value_plot_list1 = parameter(idx_list_loop,colm_in_para_list(1));
                current_value_plot_list2 = parameter(idx_list_loop,colm_in_para_list(2));
                % search list for parameters 1 and 2 that meet the
                % para_1_values and para_2_values simultanousely
                rel_error_para1 = abs((para_1_value - current_value_plot_list1)./current_value_plot_list1);
                rel_error_para2 = abs((para_2_value -current_value_plot_list2)./current_value_plot_list2);
                if ~isempty(find(rel_error_para1 < 1e-3)) && ~isempty(find(rel_error_para2 < 1e-3))                    
                    if strcmp(lower(data_FOM.str), 'max')
                        if ~isempty(dummy_value)
                            if FOM(idx_list_loop) > dummy_value
                                extracted_results{idx_para2,idx_para1} = results_structure{idx_list_loop};
                                extracted_parameters{idx_para2,idx_para1} = parameter(idx_list_loop,:);
                                dummy_value = FOM(idx_list_loop);
                            end
%                             dummy_value = max(FOM(idx_list_loop), dummy_value);
                        else
                            extracted_results{idx_para2,idx_para1} = results_structure{idx_list_loop};
                            extracted_parameters{idx_para2,idx_para1} = parameter(idx_list_loop,:);FOM(idx_list_loop);
                                dummy_value = FOM(idx_list_loop);
                        end
                    elseif strcmp(lower(data_FOM.str), 'min')
                        if ~isempty(dummy_value)
                            if FOM(idx_list_loop) < dummy_value
                                extracted_results{idx_para2,idx_para1} = results_structure{idx_list_loop};
                                extracted_parameters{idx_para2,idx_para1} = parameter(idx_list_loop,:);
                                dummy_value = FOM(idx_list_loop);
                            end
                        else
                            extracted_results{idx_para2,idx_para1} = results_structure{idx_list_loop};
                            extracted_parameters{idx_para2,idx_para1} = parameter(idx_list_loop,:);
                            dummy_value = FOM(idx_list_loop);
                        end
                    else
                        error_prompt = ('FOM_minORmax not defined correctly - options min or max');
                        return
                    end
                end
            end
        end
 end
data_axis{1} = para{1};
data_axis{2} = para{2};
end